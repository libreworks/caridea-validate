<?php
/**
 * Caridea
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 * @copyright 2015-2018 LibreWorks contributors
 * @license   Apache-2.0
 */
namespace Caridea\Validate;

/**
 * Generated by hand
 */
class RegistryTest extends \PHPUnit\Framework\TestCase
{
    /**
     * @var Registry
     */
    protected $object;

    /**
     * Sets up the fixture
     */
    protected function setUp()
    {
        $this->object = new Registry();
    }

    /**
     * @covers Caridea\Validate\Registry::__construct
     * @covers Caridea\Validate\Parser::__construct
     * @covers Caridea\Validate\Registry::register
     */
    public function testRegister()
    {
        $this->object->register(['test' => function ($b, $c) {
            $this->assertEquals('foo', $b);
            $this->assertEquals('bar', $c);
            return Rule\Compare::max(123);
        }]);
        $f = $this->object->factory('test', ['foo', 'bar']);
        $this->assertInstanceOf(Rule\Compare::class, $f);
    }

    /**
     * @covers Caridea\Validate\Registry::register
     * @expectedException \InvalidArgumentException
     * @expectedExceptionMessage Values passed to register must be callable
     */
    public function testRegisterBad()
    {
        $this->object->register(['test' => 123]);
    }

    /**
     * @covers Caridea\Validate\Registry::__construct
     * @covers Caridea\Validate\Registry::factory
     */
    public function testFactory()
    {
        $f = $this->object->factory('required', []);
        $this->assertInstanceOf(Rule::class, $f);
    }

    /**
     * @covers Caridea\Validate\Registry::__construct
     * @covers Caridea\Validate\Registry::factory
     * @expectedException \InvalidArgumentException
     * @expectedExceptionMessage No rule registered with name: foobar
     */
    public function testFactoryMissing()
    {
        $this->object->factory('foobar', []);
    }

    /**
     * @covers Caridea\Validate\Registry::__construct
     * @covers Caridea\Validate\Registry::factory
     * @expectedException \UnexpectedValueException
     * @expectedExceptionMessage Definitions must return Rule objects
     */
    public function testFactoryUncallable()
    {
        $this->object->register(['foobar' => function () {
            return 'hi';
        }]);
        $this->object->factory('foobar', []);
    }

    /**
     * @covers Caridea\Validate\Registry::builder
     */
    public function testBuilder()
    {
        $registry = new Registry();
        $builder = $registry->builder();
        $this->assertInstanceOf(Builder::class, $builder);
        $this->assertAttributeInstanceOf(Parser::class, 'parser', $builder);
    }

    /**
     * @covers Caridea\Validate\Registry::alias
     * @covers Caridea\Validate\Parser::parse
     * @covers Caridea\Validate\Parser::getRule
     */
    public function testAlias()
    {
        $registry = new Registry();
        $definition = (object)[
            'nested_object' => (object)[
                'country' => 'required',
                'city' => 'required',
                'zip' => 'positive_integer',
            ]
        ];
        $this->assertSame($registry, $registry->alias('valid_address', $definition));
        $parser = new Parser($registry);
        $rule = $parser->getRule('valid_address');
        $this->assertInstanceOf(Rule\Set::class, $rule);
        $this->assertNull($rule->apply(['country' => 'US', 'city' => 'Somewhere', 'zip' => 12345]));
        $this->assertEquals(['country' => 'REQUIRED', 'city' => 'REQUIRED', 'zip' => 'NOT_POSITIVE_INTEGER'], $rule->apply(['zip' => 'hi']));
    }

    /**
     * @covers Caridea\Validate\Registry::alias
     * @covers Caridea\Validate\Parser::parse
     * @covers Caridea\Validate\Parser::getRule
     */
    public function testAliasError()
    {
        $registry = new Registry();
        $definition = (object)[
            'nested_object' => (object)[
                'country' => 'required',
                'city' => 'required',
                'zip' => 'positive_integer',
            ]
        ];
        $this->assertSame($registry, $registry->alias('valid_address', $definition, 'WRONG_ADDRESS'));
        $parser = new Parser($registry);
        $rule = $parser->getRule('valid_address');
        $this->assertInstanceOf(Rule\Set::class, $rule);
        $this->assertNull($rule->apply(['country' => 'US', 'city' => 'Somewhere', 'zip' => 12345]));
        $this->assertEquals(['WRONG_ADDRESS'], $rule->apply(['zip' => 'hi']));
    }

    /**
     * @covers Caridea\Validate\Registry::alias
     * @covers Caridea\Validate\Parser::parse
     * @covers Caridea\Validate\Parser::getRule
     */
    public function testAlias2()
    {
        $registry = new Registry();
        $definition = [ 'positive_integer', [ 'min_number' => 18 ] ];
        $this->assertSame($registry, $registry->alias('adult_age', $definition));
        $parser = new Parser($registry);
        $rule = $parser->getRule('adult_age');
        $this->assertInstanceOf(Rule\Set::class, $rule);
        $this->assertNull($rule->apply(19));
        $this->assertEquals(['NOT_POSITIVE_INTEGER'], $rule->apply('a'));
    }

    /**
     * @covers Caridea\Validate\Registry::alias
     * @covers Caridea\Validate\Parser::parse
     * @covers Caridea\Validate\Parser::getRule
     */
    public function testAlias2Error()
    {
        $registry = new Registry();
        $definition = [ 'positive_integer', [ 'min_number' => 18 ] ];
        $this->assertSame($registry, $registry->alias('adult_age', $definition, 'WRONG_AGE'));
        $parser = new Parser($registry);
        $rule = $parser->getRule('adult_age');
        $this->assertInstanceOf(Rule\Set::class, $rule);
        $this->assertNull($rule->apply(19));
        $this->assertEquals(['WRONG_AGE'], $rule->apply('a'));
    }

    /**
     * @covers Caridea\Validate\Registry::aliasDefinition
     * @expectedException \InvalidArgumentException
     * @expectedExceptionMessage Invalid alias definition: must be an object or an associative array
     */
    public function testAliasDefinitionArguments()
    {
        $registry = new Registry();
        $registry->aliasDefinition('foo');
    }

    /**
     * @covers Caridea\Validate\Registry::aliasDefinition
     * @expectedException \InvalidArgumentException
     * @expectedExceptionMessage Invalid alias definition: must have 'name' and 'rules' fields
     */
    public function testAliasDefinitionArguments2()
    {
        $registry = new Registry();
        $registry->aliasDefinition(['foo' => 'bar']);
    }

    /**
     * @covers Caridea\Validate\Registry::aliasDefinition
     * @covers Caridea\Validate\Registry::alias
     * @covers Caridea\Validate\Parser::getRule
     */
    public function testAliasDefinition()
    {
        $registry = new Registry();
        $definition = (object)[
            'name' => 'valid_address',
            'rules' => (object)[
                'nested_object' => (object)[
                    'country' => 'required',
                    'city' => 'required',
                    'zip' => 'positive_integer',
                ]
            ],
        ];
        $this->assertSame($registry, $registry->aliasDefinition($definition));
        $parser = new Parser($registry);
        $rule = $parser->getRule('valid_address');
        $this->assertInstanceOf(Rule\Set::class, $rule);
        $this->assertNull($rule->apply(['country' => 'US', 'city' => 'Somewhere', 'zip' => 12345]));
        $this->assertEquals(['country' => 'REQUIRED', 'city' => 'REQUIRED', 'zip' => 'NOT_POSITIVE_INTEGER'], $rule->apply(['zip' => 'hi']));
    }

    /**
     * @covers Caridea\Validate\Registry::aliasDefinition
     * @covers Caridea\Validate\Registry::alias
     * @covers Caridea\Validate\Parser::getRule
     */
    public function testAliasDefinitionError()
    {
        $registry = new Registry();
        $definition = (object)[
            'name' => 'valid_address',
            'rules' => (object)[
                'nested_object' => (object)[
                    'country' => 'required',
                    'city' => 'required',
                    'zip' => 'positive_integer',
                ]
            ],
            'error' => 'WRONG_ADDRESS',
        ];
        $this->assertSame($registry, $registry->aliasDefinition($definition));
        $parser = new Parser($registry);
        $rule = $parser->getRule('valid_address');
        $this->assertInstanceOf(Rule\Set::class, $rule);
        $this->assertNull($rule->apply(['country' => 'US', 'city' => 'Somewhere', 'zip' => 12345]));
        $this->assertEquals(['WRONG_ADDRESS'], $rule->apply(['zip' => 'hi']));
    }
}
